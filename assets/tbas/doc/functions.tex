\label{functions}

Functions are a form of expression that may taks input arguments surrounded by parentheses. Most of the traditional BASIC \emph{statements} that does not return a value are \emph{functions} in \tbas , and like those, while \tbas{} functions can be called without parentheses, it is highly \emph{discouraged} because of the ambiguities in syntax. \textbf{Always use parentheses on function call!}

\section{Mathematical}

    \subsection{ABS}
        \codeline{Y \textbf{= ABS(}X\textbf{)}}\par
        Returns absolute value of \code{X}.
    \subsection{ACO}
        \codeline{Y \textbf{= ACO(}X\textbf{)}}\par
        Returns inverse cosine of \code{X}.
    \subsection{ASN}
        \codeline{Y \textbf{= ASN(}X\textbf{)}}\par
        Returns inverse sine of \code{X}.
    \subsection{ATN}
        \codeline{Y \textbf{= ATN(}X\textbf{)}}\par
        Returns inverse tangent of \code{X}.
    \subsection{CBR}
        \codeline{Y \textbf{= CBR(}X\textbf{)}}\par
        Returns cubic root of \code{X}.
    \subsection{CEIL}
        \codeline{Y \textbf{= CEIL(}X\textbf{)}}\par
        Returns integer value of \code{X}, truncated towards positive infinity.
    \subsection{COS}
        \codeline{Y \textbf{= COS(}X\textbf{)}}\par
        Returns cosine of \code{X}.
    \subsection{COSH}
        \codeline{Y \textbf{= COSH(}X\textbf{)}}\par
        Returns hyperbolic cosine of \code{X}.
    \subsection{EXP}
        \codeline{Y \textbf{= EXP(}X\textbf{)}}\par
        Returns exponential of \code{X}, i.e. $e^X$.
    \subsection{FIX}
        \codeline{Y \textbf{= FIX(}X\textbf{)}}\par
        Returns integer value of \code{X}, truncated towards zero.
    \subsection{FLOOR, INT}
        \codeline{Y \textbf{=} \{\textbf{FLOOR}|\textbf{INT}\}\textbf{(}X\textbf{)}}\par
        Returns integer value of \code{X}, truncated towards negative infinity.
    \subsection{LEN}
        \codeline{Y \textbf{= LEN(}X\textbf{)}}\par
        Returns length of \code{X}. \code{X} can be either a string or an array.
    \subsection{LOG}
        \codeline{Y \textbf{= LOG(}X\textbf{)}}\par
        Returns natural logarithm of \code{X}.
    \subsection{ROUND}
        \codeline{Y \textbf{= ROUND(}X\textbf{)}}\par
        Returns closest integer value of \code{X}, rounding towards positive infinity.
    \subsection{RND}
        \codeline{Y \textbf{= RND(}X\textbf{)}}\par
        Returns a random number within the range of $[0..1)$. If \code{X} is zero, previous random number will be returned; otherwise new random number will be returned.
    \subsection{SIN}
        \codeline{Y \textbf{= SIN(}X\textbf{)}}\par
        Returns sine of \code{X}.
    \subsection{SINH}
        \codeline{Y \textbf{= SINH(}X\textbf{)}}\par
        Returns hyperbolic sine of \code{X}.
    \subsection{SGN}
        \codeline{Y \textbf{= SGN(}X\textbf{)}}\par
        Returns sign of \code{X}: 1 for positive, -1 for negative, 0 otherwise.
    \subsection{SQR}
        \codeline{Y \textbf{= SQR(}X\textbf{)}}\par
        Returns square root of \code{X}.
    \subsection{TAN}
        \codeline{Y \textbf{= TAN(}X\textbf{)}}\par
        Returns tangent of \code{X}.
    \subsection{TANH}
        \codeline{Y \textbf{= TANH(}X\textbf{)}}\par
        Returns hyperbolic tangent of \code{X}.

\section{Input}

    \subsection{DIM}
        \codeline{Y \textbf{= DIM(}X\textbf{)}}\par
        Returns array with size of \code{X}, all filled with zero.
    \subsection{GETKEYSDOWN}
        \codeline{\textbf{GETKEYSDOWN} VARIABLE}\par
        Stores array that contains keycode of keys held down in \code{VARIABLE}.\par
        Actual keycode and the array length depends on the machine: in \thismachine , array length will be fixed to 8. For the list of available keycodes, see \ref{implementation}.
    \subsection{INPUT}
        \codeline{\textbf{INPUT} VARIABLE}\par
        Prints out \code{? } to the console and waits for user input. Input can be any length and terminated with return key. The input will be stored to given variable.

\section{Output}

    \subsection{EMIT}
        \codeline{\textbf{EMIT(}EXPR [\{\textbf{,}|\textbf{;}\} EXPR]...\textbf{)}}\par
        Prints out characters corresponding to given number on the code page being used.\par
        \code{EXPR} is numeric expression.
    \subsection{PRINT}
        \codeline{\textbf{PRINT(}EXPR [\{\textbf{,}|\textbf{;}\} EXPR]...\textbf{)}}\par
        Prints out given string expressions.\par
        \code{EXPR} is a string, numeric expression, or array.\par
        \code{PRINT} is one of the few function that differentiates two style of argument separator: \codebf{;} will simply concatenate two expressions (unlike traditional BASIC, numbers will not have surrounding spaces), \codebf{,} tabulates the expressions.

\section{Program Manipulation}

    \subsection{CLEAR}
        \codeline{\textbf{CLEAR}}\par
        Clears all declared variables.
    \subsection{DATA}
        \codeline{\textbf{DATA} CONST0 [\textbf{,} CONST1]...}\par
        Adds data that can be read by \code{READ} function.
        \subsubsection*{Notes}
        \begin{itemlist}
        \item \code{DATA} declarations need not be reacheable in the program flow
        \end{itemlist}
    \subsection{END}
        \codeline{\textbf{END}}\par
        Stops program execution and returns control to the user.
    \subsection{FOR}
        \codeline{\textbf{FOR} LOOPVAR \textbf{=} START \textbf{TO} STOP [\textbf{STEP} STEP]}
        \codeline{\textbf{FOR} LOOPVAR \textbf{=} GENERATOR}\par
        Starts a \code{FOR-NEXT} loop.\par
        Initially, \code{LOOPVAR} is set to \code{START} then statements between the \code{FOR} statement and corresponding \code{NEXT} statements are executed and \code{LOOPVAR} is incremented by \code{STEP}, or by 1 if \code{STEP} is not specified. The program flow will continue to loop around until \code{LOOPVAR} is outside the range of \code{START}--\code{STOP}. The value of the \code{LOOPVAR} is equal to \code{STOP}$+$\code{STEP} when the looping finishes.
    \subsection{FOREACH}
        \codeline{\textbf{FOREACH} LOOPVAR \textbf{IN} ARRAY}\par
        Same as \code{FOR} but fetches \code{LOOPVAR} from given \code{ARRAY}.
    \subsection{GOSUB}
        \codeline{\textbf{GOSUB} LINENUM}\par
        Jumps to a subroutine at \code{LINENUM}. The next \code{RETURN} statements makes program flow to jump back to the statement after the \code{GOSUB}.\par
        \code{LINENUM} can be either a numeric expression or a Label.
    \subsection{GOTO}
        \codeline{\textbf{GOTO} LINENUM}\par
        Jumps to \code{LINENUM}.\par
        \code{LINENUM} can be either a numeric expression or a Label.
    \subsection{LABEL}
        \codeline{\textbf{LABEL} NAME}\par
        Puts a name onto the line numeber the statement is located. Jumping to the \code{NAME}
        \subsubsection*{Notes}
        \begin{itemlist}
        \item \code{NAME} must be a valid variable name
        \end{itemlist}
    \subsection{NEXT}
        \codeline{\textbf{NEXT}}\par
        Iterates \code{FOR-NEXT} loop and increments the loop variable from the most recent \code{FOR} statement and jumps to that statement.
    \subsection{READ}
        \codeline{\textbf{READ} VARIABLE}\par
        Assigns data declared from \code{DATA} statements to given variable. Reading starts at the current \code{DATA} position, and the data position will be incremented by one. The position is reset to the zero by the \code{RUN} command.
    \subsection{RESTORE}
        \codeline{\textbf{RESTORE}}\par
        Resets the \code{DATA} pointer.
    \subsection{RETURN}
        \codeline{\textbf{RETURN}}\par
        Returns from the \code{GOSUB} statement.

\section{String Manipulation}

    \subsection{CHR}
        \codeline{CHAR \textbf{= CHR(}X\textbf{)}}\par
        Returns the character with code point of \code{X}. Code point is a numeric expression in the range of $[0-255]$.
    \subsection{LEFT}
        \codeline{SUBSTR \textbf{= LEFT(}STR\textbf{,}NUM\_CHARS\textbf{)}}\par
        Returns the leftmost \code{NUM\_CHARS} characters of \code{STR}.
    \subsection{MID}
        \codeline{SUBSTR \textbf{= MID(}STR\textbf{,}POSITION\textbf{,}LENGTH\textbf{)}}\par
        Returns a substring of \code{STR} starting at \code{POSITION} with specified \code{LENGTH}.\par
        When \code{OPTIONBASE 1} is specified, the position starts from 1; otherwise it will start from 0. 
    \subsection{RIGHT}
        \codeline{SUBSTR \textbf{= RIGHT(}STR\textbf{,}NUM\_CHARS\textbf{)}}\par
        Returns the rightmost \code{NUM\_CHARS} characters of \code{STR}.
    \subsection{SPC}
        \codeline{STR \textbf{= SPC(}STR\textbf{,}NUM\_CHARS\textbf{)}}\par
        Returns a string of \code{NUM\_CHARS} spaces.
\section{Graphics}

    \subsection{PLOT}
        \codeline{\textbf{PLOT(}X\_POS\textbf{,}Y\_POS\textbf{,}COLOUR\textbf{)}}\par
        Plots a pixel to the framebuffer of the display, at XY-position of \code{X\_POS} and \code{Y\_POS}, with colour of \code{COLOUR}.\par
        Top-left corner of the pixel will be 1 if \code{OPTIONBASE 1} is specified; otherwise it will be 0.

\section{Meta}

    \subsection{OPTIONBASE}
        \codeline{\textbf{OPTIONBASE} \{\textbf{0}|\textbf{1}\}}\par
        Specifies at which number the array/string/pixel indices begin.
    \subsection{OPTIONDEBUG}
        \codeline{\textbf{OPTIONDEBUG} \{\textbf{0}|\textbf{1}\}}\par
        Specifies whether or not the debugging messages should be printed out.\par
        The messages will be printed out to the \emph{serial debugging console}, or to the stdout.
    \subsection{OPTIONTRACE}
        \codeline{\textbf{OPTIONTRACE} \{\textbf{0}|\textbf{1}\}}\par
        Specifies whether or not the line numbers should be printed out.\par
        The messages will be printed out to the \emph{serial debugging console}, or to the stdout.

\section{System}

    \subsection{PEEK}
        \codeline{BYTE \textbf{= PEEK(}MEMADDR\textbf{)}}\par
        Returns whatever the value stored in the \code{MEMADDR} of the scratchpad-memory.\par
        Address mirroring, illegal access, etc. are entirely up to the virtual machine which the BASIC interpreter is running on.
    \subsection{POKE}
        \codeline{\textbf{POKE(}MEMADDR\textbf{,}BYTE\textbf{)}}\par
        Puts a \code{BYTE} into the \code{MEMADDR} of the scratchpad-memory.

\section{Higher-order Function}

    \subsection{CURRY}
    \subsection{DO}
    \subsection{FILTER}
    \subsection{FOLD}
    \subsection{MAP}
