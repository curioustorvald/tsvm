\quad
\chapterprecishere{``Begin at the beginning'', the King said gravely, ``and go on till you come to the end: then stop.''\par\raggedleft --- \textup{Lewis Carroll, } Alice in Wonderland}

We'll begin at the beginning; how beginning? This:

\begin{lstlisting}
10 PRINT 2+2
run
4
Ok
\end{lstlisting}

Oh \emph{boy} we just did a computation! It printed out \code{4} which is a correct answer for $2+2$ and it didn't crash!

\begin{lstlisting}
10 DEFUN FAC(N)=IF N==0 THEN 1 ELSE N*FAC(N-1)
20 FOR K=1 TO 6
30 PRINT FAC(K)
40 NEXT
\end{lstlisting}

\begin{lstlisting}
10 DEFUN FAC(N)=IF N==0 THEN 1 ELSE N*FAC(N-1)
20 K=MAP FAC, 1 TO 10
30 PRINT K
\end{lstlisting}


\begin{lstlisting}
10 DEFUN FIB(N)=IF N==0 THEN 0 ELSE IF N==1 THEN 1 ELSE FIB(N-1)+FIB(N-2)
20 FOR K=1 TO 12
30 PRINT FIB(K);" ";
40 NEXT
\end{lstlisting}

\section[Currying]{Haskell Curry Wants to Know Your Location}

So what the fsck is currying? Consider the following code:

\begin{lstlisting}
10 DEFUN F(K,T)=ABS(T)==K
20 CF=F<~32
30 PRINT CF(24) : REM will print 'false'
40 PRINT CF(-32) : REM will print 'true'
\end{lstlisting}

% NOTE: you can't use \basiccurry within \code{}
Here, \code{CF} is a curried function of \code{F}; built-in operator \code{$<\!\sim$} applies \code{32} to the first parameter of the function \code{F}, which dynamically returns a \emph{function} of \code{CF(T) = ABS(T) == 32}. The fact that Curry Operator returns a \emph{function} opens many possibilities, for example, you can create loads of sibling functions without making loads of duplicate codes.

\section[Wrapping-Up]{The Grand Unification}

Using all the knowledge we have learned, it should be trivial\footnote{/s} to write a Quicksort function in \tbas, like this:

\begin{lstlisting}
10 DEFUN LESS(P,X)=X<P
11 DEFUN GTEQ(P,X)=X>=P
12 DEFUN QSORT(XS)=IF LEN(XS)<1 THEN NIL ELSE 
    QSORT(FILTER(LESS<~HEAD(XS),TAIL(XS))) # HEAD(XS)!NIL # 
    QSORT(FILTER(GTEQ<~HEAD(XS),TAIL(XS)))
100 L=7!9!4!5!2!3!1!8!6!NIL
110 PRINT L
120 PRINT QSORT(L)
\end{lstlisting}

Line 12 implements quicksort algorithm, using \code{LESS} and \code{GTEQ} as helper functions. \code{LESS} is a user-function version of less-than operator, and \code{GTEQ} is similar. \code{QSORT} selects a pivot by taking the head-element of the array \code{XS}\footnote{stands for \emph{X's}} with \code{HEAD(XS)}, then utilises curried version of \code{LESS} and \code{GTEQ} to move lesser-than-pivot values to the left and greater to the right (the head element itself does not get recursed, here \code{TAIL(XS)} is applied to make head-less copy of the array), and these two separated \emph{chunks} are recursively sorted using the same \code{QSORT} function. Currying is exploited to give comparison functions a pivot-value to compare against, and also because \code{FILTER} wants a \emph{function} and not an \emph{expression}. \code{HEAD(XS)!NIL} creates a single-element array contains head-element of the \code{XS}.

%Uncomment this if you finally decided to support a closure%
%% Using \emph{closure}, the definition of \code{QSORT} can truly be a one-liner and be \emph{even more cryptic}:
%% 
%% \begin{lstlisting}
%% 10 QSORT=[XS]~>IF LEN(XS)<1 THEN NIL ELSE 
%%     QSORT(FILTER([K]~>K<HEAD XS,TAIL XS)) # HEAD(XS)!NIL # 
%%     QSORT(FILTER([K]~>K>=HEAD XS,TAIL XS))
%% \end{lstlisting}
